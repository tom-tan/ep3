#!/usr/bin/env ruby
# coding: utf-8
require 'optparse'
require 'fileutils'
require 'tmpdir'
require 'json'
require 'time'

Quiet = 0
Normal = 1
Verbose = 2
VeryVerbose = 3

def run_cmd(cmd, loglevel)
  pid = nil
  begin
    ret = system(cmd)
    status = $?
    hash = {
      'success' => ret,
      'commmand' => cmd, 'return' => status.exitstatus,
      'tag' => 'ep3.system', 'timestamp' => Time.now.iso8601(7),
    }
    if loglevel >= Verbose
      warn JSON.dump hash
    end
    hash
  rescue SignalException
    hash = {
      'success' => false,
      'commmand' => cmd, 'interrupted' => true,
      'tag' => 'ep3.system', 'timestamp' => Time.now.iso8601(7),
    }
    if loglevel >= Verbose
      puts JSON.dump hash
    end
    hash
  rescue => e
    hash = {
      'success' => false,
      'commmand' => cmd, 'message' => e.to_s,
      'tag' => 'ep3.system', 'timestamp' => Time.now.iso8601(7),
    }
    if loglevel >= Verbose
      puts JSON.dump hash
    end
    hash
  ensure
    unless pid.nil?
      Process.kill :TERM, pid
      Process.wait pid
    end
  end
end

if $0 == __FILE__
  extensions = []
  loglevel = Normal

  parser = OptionParser.new
  parser.banner = "Usage: #{$0} cwl [jobfile]"
  parser.on('--tmpdir=TMP', 'directory for temporary files')
  parser.on('--outdir=OUT', 'directory for output objects')
  parser.on('--leave-tmpdir', 'do not remove temporary directory')
  parser.on('--quiet', 'disable information output') {
    loglevel = Quiet
  }
  parser.on('--verbose', 'verbose output') {
    loglevel = Verbose
  }
  parser.on('--veryverbose', 'more verbose output') {
    loglevel = VeryVerbose
  }
  parser.on('--debug', 'same as --veryverbose (deprecated)') {
    loglevel = VeryVerbose
  }
  parser.on('--extension=EXT', 'specify extension') { |ext|
    extensions.push ext
  }
  parser.on('--version', 'show version information') {
    system('git describe', :chdir => File.dirname($0))
    exit
  }

  basedir = File.dirname(File.realpath($0))

  opts = parser.getopts(ARGV)
  unless ARGV.length == 1 or ARGV.length == 2
    puts parser.help
    exit
  end

  cwl = ARGV.shift
  job = if ARGV.empty?
          nil
        else
          ARGV.shift
        end

  # Note: Dir.mktmpdir includes side effect
  tmpdir = opts.fetch('tmpdir', Dir.mktmpdir)
  target_arg = "--target-dir=#{tmpdir}"

  outdir = opts.fetch('outdir', '.')
  dst_arg = "--destination=#{outdir}"

  ret_init = run_cmd("#{basedir}/ep3 init --force #{target_arg} #{cwl} > /dev/null", loglevel)
  unless ret_init['success']
    exit ret_init.fetch('return', 1)
  end

  begin
    unless extensions.empty?
      ret_hook = run_cmd("#{basedir}/ep3 hook --extensions=#{extensions.join(',')} #{target_arg}", debug)
      if ret_hook.include? 'interrupted'
        exit 1
      elsif not ret_hook['success']
        exit ret_hook.fetch('return', 1)
      end
    end

    lopt = case loglevel
           when Quiet       then '--quiet'
           when Normal      then ''
           when Verbose     then '--verbose'
           when VeryVerbose then '--veryverbose'
           end
    ret_run = run_cmd("#{basedir}/ep3 run #{lopt} #{target_arg} #{job}", loglevel)

    if ret_run.include? 'interrupted'
      exit 1
    elsif not ret_run['success']
      exit ret_run.fetch('return', 1)
    end

    ret_list = run_cmd("#{basedir}/ep3 list #{target_arg} --copy #{dst_arg}", loglevel)
    if ret_list['success']
      exit 0
    else
      exit ret_list.fetch('success', 1)
    end    
  rescue => e
    raise e
  ensure
    leave_dir_arg = if opts.include? 'leave-tmpdir'
                      '--leave-tmpdir '
                    else
                      ''
                    end
    unless opts.include? 'leave-tmpdir'
      FileUtils.remove_entry tmpdir
    end
  end
end
