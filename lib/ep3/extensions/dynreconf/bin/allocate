#!/usr/bin/env ruby
# coding: utf-8
require 'optparse'
require 'json'
require_relative '../lib/rest'
require_relative "#{ENV['EP3_LIBPATH']}/runtime/inspector"

def parse_option_file(file)
  if File.exist? file
    open(file) { |f|
      JSON.load(f)
    }
  else
    {}
  end
end

def to_reconf_params(cwl_file, params_file, id)
  cwl = CommonWorkflowLanguage.load_file(cwl_file)
  params = open(params_file) { |f|
    JSON.load(f)
  }
  {
    input_params: Hash[params.keep_if{ |k, v|
      v.instance_of?(Hash) and v.fetch('class', '') == 'File'
    }.map{ |k, v|
      [k, v['size']/(1024.0**3)]
    }],
    tool_id: get_requirement(cwl, 'DockerRequirement').dockerPull,
    next_step_uuid: nil,
    workflow_name: 'job.cwl',
    workflow_invocation_id: id,
  }
end

# Poll example for /status/$req_id
#  {
#    "done": true,
#    "data": {
#      "type": "reconf",
#      "success": true,
#      "error_message": "",
#      "result": {
#        "i1": {
#          "properties": {
#            "cost": 0.768,
#            "flavor": "c5.4xlarge",
#            "memory": 32,
#            "ncores": 16,
#            "provider": "aws",
#            "region": "ap-northeast-2",
#            "storage": 8
#          },
#          "result": {
#            "endpoint": "172.30.2.193",
#            "error_message": "",
#            "success": true,
#            "resource_req_id": "8e7c8f75f33d488daa73317156491118"
#          }
#        }
#      }
#    }
#  }

def allocate_main(args)
  options = {
    'as': nil,
  }
  timeout = 10*60 # 10 min.
  dry_run = false
  nowait = false
  opt_file = '.reconf.json'
  opt = OptionParser.new
  opt.banner = "Usage: #{File.basename $0} [options] cwl params plan-result"
  # common options
  # cwl: A file name for tool definition
  # params: A file name for input parameters
  # user-requirements: A file name for user requirements
  opt.on('--timeout=TO', "Timeout in seconds (default: #{timeout} sec.)") { |to|
    timeout = to.to_i
  }
  opt.on('--config=FILE',
         "A file name for configuration params such as ra and ms endpoints (default: #{opt_file})") { |f|
    unless File.exist? f
      warn "File not found: #{f}"
      exit 1
    end
    opt_file = f
  }
  opt.on('--dry-run', 'Print parameters') {
    dry_run = true
  }
  opt.on('--nowait', 'Post parameters and immediately exit') {
    nowait = true
  }

  # reconf allocator specific options
  opt.on('--as-endpoint=AS', 'An endpoint to an application scheduler') { |as|
    options['as'] = as
  }

  opt.parse!(args)
  unless args.length == 3
    puts opt.help
    return 0
  end

  cwl, params, plan = *args

  raise "File not found: #{cwl}" unless File.exist? cwl
  raise "File not found: #{params}" unless File.exist? params
  raise "File not found: #{plan}" unless File.exist? plan

  options = parse_option_file(opt_file).merge(options)
  as_server = options['as']

  invocation_id = open(plan) { |f|
    JSON.load(f)
  }['invocation_id']

  ps = to_reconf_params(cwl, params, invocation_id)
  if dry_run
    puts JSON.dump(ps)
    return 0
  end

  body = post_request("#{as_server}/reconf", ps)
  if nowait
    puts JSON.dump({
      invocation_id: invocation_id,
      reconf_params: ps,
      post_response: body,
    })
    return 0
  end

  begin
    id = body['req_id']
    endpoint = "#{as_server}/status/#{id}"
    allocated = poll(endpoint, timeout) do |code, res|
      if code == 200 && res['done'] && res['data']['success']
        break(res['data']['result']['i1'])
      elsif code != 200 || (res['done'] && not(res['data']['success']))
        raise JSON.dump({
          message: 'Error in poll',
          file: __FILE__,
          line: __LINE__,
          code: code,
          endpoint: endpoint,
          body: res,
          reconf_params: ps,
        })
      end
    end

    if allocated
      puts JSON.dump(allocated)
      0
    else
      raise JSON.dump({
        message: 'Timeout to allocate a resource',
        invocation_id: invocation_id,
        reconf_params: ps,
        post_response: body,
      })
    end
  rescue SignalException
    raise JSON.dump({
      message: 'Terminate allocation due to interruption',
      invocation_id: invocation_id,
      reconf_params: ps,
      post_response: body,
    })
  end
end

if $0 == __FILE__
  begin
      exit allocate_main(ARGV)
  rescue => e
      json = nil
      begin
          json = JSON.load(e.message)
      rescue JSON::ParserError
          json = {
              message: "Unknown error",
              exception: e.full_message(highlight: false),
          }
      end
      warn JSON.dump(json)
      exit 1
  end
end
