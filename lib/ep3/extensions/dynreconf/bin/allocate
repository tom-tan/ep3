#!/usr/bin/env ruby
# coding: utf-8
require 'optparse'
require 'json'
require 'net/http'
require_relative "#{ENV['EP3_LIBPATH']}/runtime/inspector"

def parse_option_file(file)
  if File.exist? file
    open(file) { |f|
      JSON.load(f)
    }
  else
    {}
  end
end

def to_reconf_params(cwl_file, params_file, id)
  cwl = CommonWorkflowLanguage.load_file(cwl_file)
  params = open(params_file) { |f|
    JSON.load(f)
  }
  {
    input_params: Hash[params.keep_if{ |k, v|
      v.instance_of?(Hash) and v.fetch('class', '') == 'File'
    }.map{ |k, v|
      [k, v['size']/(1024.0**3)]
    }],
    tool_id: get_requirement(cwl, 'DockerRequirement').dockerPull,
    next_step_uuid: nil,
    workflow_name: 'job.cwl',
    workflow_invocation_id: id,
  }
end

def post_request(endpoint, params)
  uri = URI.parse(endpoint)
  http = Net::HTTP.new(uri.host, uri.port)
  headers = { 'Content-Type' => 'application/json' }
  response = http.post(uri.path, JSON.dump(params), headers)

  raise "Error in creation: #{response.body}" if response.code != '201'

  JSON.load(response.body)
  # {
  #   req_id: xxx
  # }
end

def poll(endpoint, timeout)
  uri = URI.parse(endpoint)
  http = Net::HTTP.new(uri.host, uri.port)
  headers = { 'Content-Type' => 'application/json' }
  start = Time.now
  json = nil
  (timeout/10.0).ceil.times{
    response = http.get(uri, headers)
    json = JSON.load(response.body)
    if response.code == '200'
      break if json['done'] and json['data']['success']
    else
      warn "Warning: code: #{response.code}, body: #{JSON.dump(response.body)}"
    end

    unless json['data']['success']
      warn "Error: request failed"
      break
    end

    break if Time.now-start > timeout
    sleep 10
  }
  json['data']['result']['i1']
#  body = {
#    "done": true,
#    "data": {
#      "type": "reconf",
#      "success": true,
#      "error_message": "",
#      "result": {
#        "i1": {
#          "properties": {
#            "cost": 0.768,
#            "flavor": "c5.4xlarge",
#            "memory": 32,
#            "ncores": 16,
#            "provider": "aws",
#            "region": "ap-northeast-2",
#            "storage": 8
#          },
#          "result": {
#            "endpoint": "172.30.2.193",
#            "error_message": "",
#            "success": true,
#            "resource_req_id": "8e7c8f75f33d488daa73317156491118"
#          }
#        }
#      }
#    }
#  }
end

if $0 == __FILE__
  options = {
    'as': nil,
  }
  timeout = 10*60 # 10 min.
  dry_run = false
  nowait = false
  opt_file = '.reconf.json'
  opt = OptionParser.new
  opt.banner = "Usage: #{$0} [options] cwl params plan-result"
  # common options
  # cwl: A file name for tool definition
  # params: A file name for input parameters
  # user-requirements: A file name for user requirements
  opt.on('--timeout=TO', "Timeout in seconds (default: #{timeout} sec.)") { |to|
    timeout = to.to_i
  }
  opt.on('--config=FILE',
         "A file name for configuration params such as ra and ms endpoints (default: #{opt_file})") { |f|
    unless File.exist? f
      warn "File not found: #{f}"
      exit 1
    end
    opt_file = f
  }
  opt.on('--dry-run', 'Print parameters') {
    dry_run = true
  }
  opt.on('--nowait', 'Post parameters and immediately exit') {
    nowait = true
  }

  # reconf allocator specific options
  opt.on('--as-endpoint=AS', 'An endpoint to an application scheduler') { |as|
    options['as'] = as
  }

  opt.parse!(ARGV)
  unless ARGV.length == 3
    puts opt.help
    exit
  end

  cwl, params, plan = *ARGV

  raise "File not found: #{cwl}" unless File.exist? cwl
  raise "File not found: #{params}" unless File.exist? params
  raise "File not found: #{plan}" unless File.exist? plan

  options = parse_option_file(opt_file).merge(options)
  as_server = options['as']

  invocation_id = open(plan) { |f|
    JSON.load(f)
  }['invocation_id']

  ps = to_reconf_params(cwl, params, invocation_id)
  if dry_run
    puts JSON.dump(ps)
    exit
  end

  body = post_request("#{as_server}/reconf", ps)
  if nowait
    puts JSON.dump({
      invocation_id: invocation_id,
      reconf_params: ps,
      post_response: body,
    })
    exit
  end

  begin
    id = body['req_id']
    allocated = poll("#{as_server}/status/#{id}", timeout)
    puts JSON.dump(allocated)
  rescue SignalException
    puts JSON.dump({
      messag: 'Terminate allocation due to interruption'
      invocation_id: invocation_id,
      reconf_params: ps,
      post_response: body,
    })
    1
  end
end
