#!/usr/bin/env ruby
# coding: utf-8
require 'optparse'
require 'json'
require 'securerandom'
require_relative '../lib/rest'
require_relative "#{ENV['EP3_LIBPATH']}/runtime/inspector"

def parse_option_file(file)
    if File.exist? file
        open(file) { |f|
            JSON.load(f)
        }
    else
        {}
    end
end

def cwl_to_galaxy_params(id, cwl_file)
    cwl = CommonWorkflowLanguage.load_file(File.join('steps', id, 'job.cwl'))
    container = get_requirement(cwl, 'DockerRequirement').dockerPull
    container_name = if container.include? ':'
                        container.split(':')[0]
                     else
                        container
                     end
    container_tag = if container.include? ':'
                        container.split(':')[1]
                    else
                        'latest'
                    end
    {
        annotation: "",
        content_id: container_name,
        errors: nil,
        inputs: cwl.inputs.keep_if{ |inp|
            inp.type.instance_of?(CWLType) and inp.type.type == 'File'
        }.map{ |inp|
            {
                description: inp.doc,
                name: inp.id,
            }
        },
        label: id,
        name: id,
        outputs: cwl.outputs.keep_if{ |out|
            out.type == 'File'
        }.map{ |out|
            {
                name: out.id,
                type: nil,
            }
        },
        tool_id: container_name,
        tool_version: container_tag,
        type: 'tool',
        uuid: nil,
        workflow_outputs: nil,
    }
end

def to_prepare_params(cwl_file, params_file, reqs_file, id)
    cwl = CommonWorkflowLanguage.load_file(cwl_file)
    params = open(params_file) { |f|
        JSON.load(f)
    }
    reqs = open(reqs_file) { |f|
        JSON.load(f)
    }
    {
        workflow_name: walk(cwl, '.id', cwl_file),
        as_objoctives: reqs,
        workflow_invocation_id: id,
        workflow_body: {
            workflow_name: walk(cwl, '.id', cwl_file),
            workflow_invocation_id: '__dummy__',
            workflow_first_step_inputs: {
                __unused_field_name__: {
                    input_params: Hash[params.keep_if{ |k, v|
                        v.instance_of?(Hash) and v.fetch('class', '') == 'File'
                    }.map{ |k, v|
                        [k, v['size']/(1024.0**3)]
                    }]
                }
            },
            workflow_json: {
                a_galaxy_workflow: "false",
                annotation: "",
                "format-version": "0.1",
                name: cwl_file,
                steps: Hash[cwl.steps.map{ |s|
                    [s.id, cwl_to_galaxy_params(s.id, s.run)]
                }]
            }
        }
    }
end

def plan_main(args)
    options = { 'as': nil, }
    timeout = 10*60 # 10 min.
    dry_run = false
    nowait = false
    opt_file = '.reconf.json'
    opt = OptionParser.new
    opt.banner = "Usage: #{File.basename $0} [options] cwl params reqs"
    # common options
    # cwl: A file name for tool definition
    # params: A file name for input parameters
    # user-requirements: A file name for user requirements
    opt.on('--timeout=TO', "Timeout in seconds (default: #{timeout} sec.)") do |to|
        timeout = to.to_i
    end
    opt.on('--config=FILE',
           "A file name for configuration params such as ra and ms endpoints (default: #{opt_file})") do |f|
        unless File.exist? f
            warn "File not found: #{f}"
            exit 1
        end
        opt_file = f
    end
    opt.on('--dry-run', 'Print parameters') do
        dry_run = true
    end
    opt.on('--nowait', 'Post parameters and immediately exit') do
        nowait = true
    end

    # reconf allocator specific options
    opt.on('--as-endpoint=AS', 'An endpoint to an application scheduler') do |as|
        options['as'] = as
    end

    opt.parse!(args)
    unless args.length == 3
        puts opt.help
        return 0
    end

    cwl, params, reqs = *args

    raise "File not found: #{cwl}" unless File.exist? cwl
    raise "File not found: #{params}" unless File.exist? params
    raise "File not found: #{reqs}" unless File.exist? reqs

    options = parse_option_file(opt_file).merge(options)
    as_server = options['as']

    invocation_id = SecureRandom.uuid
    ps = to_prepare_params(cwl, params, reqs, invocation_id)
    if dry_run
        puts JSON.dump(ps)
        return 0
    end

    body = post_request("#{as_server}/prepare", ps)
    if nowait
        puts JSON.dump({
            invocation_id: invocation_id,
            prepare_params: ps,
            post_response: body,
        })
        return 0
    end

    begin
        id = body['req_id']
        endpoint = "#{as_server}/status/#{id}"
        plan = poll(endpoint, timeout) do |code, res|
            if code == 200
                break(res) if res['done']
            else
                raise JSON.dump({
                    message: 'Error in poll',
                    file: __FILE__,
                    line: __LINE__,
                    code: code,
                    endpoint: endpoint,
                    body: res,
                    prepare_params: ps,
                })
            end
        end

        if plan
            puts JSON.dump({
                invocation_id: invocation_id,
                prepare_params: ps,
                response: plan,
            })
            0
        else
            raise JSON.dump({
                message: 'Timeout to make a plan',
                invocation_id: invocation_id,
                prepare_params: ps,
                post_response: body,
            })
        end
    rescue SignalException
        raise JSON.dump({
            message: 'Terminate making a plan due to interruption',
            invocation_id: invocation_id,
            prepare_params: ps,
            post_response: body,
        })
    end
end

if $0 == __FILE__
    begin
        exit plan_main(ARGV)
    rescue => e
        json = nil
        begin
            json = JSON.load(e.message)
        rescue JSON::ParserError
            json = {
                message: "Unknown error",
                exception: e.full_message(highlight: false),
            }
        end
        warn JSON.dump(json)
        exit 1
    end
end
