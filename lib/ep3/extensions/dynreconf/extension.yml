id: dynreconf
hooks:
  - target: workflow
    precondition:
      - ./bin/isAWorkflow ~(target)
      - ./bin/noSubworkflow ~(target)
      - ./bin/noScatter ~(target)
      - curl -s $AS_ENDPOINT
      - test -f $DYNRECONF_REQUIREMENTS
    operations:
      - type: replace-env
        env:
          - name: EP3_LIBPATH
            value: $EP3_LIBPATH
          - name: PATH
            value: $EP3_EXT_PATH/dynreconf/bin:~(self)
          - name: AS_ENDPOINT
            value: $AS_ENDPOINT
          - name: REQUIREMENTS_FILE
            value: $DYNRECONF_REQUIREMENTS
      - type: add-in
        target: /^start-(.+)$/
        in:
          - place: steps.~1.invocation-id
            pattern: _
            port-to: invocation-id
      - type: insert-before
        target: dup-entrypoint
        in:
          - replaced: entrypoint
            with: entrypoint_
        transitions:
          - name: plan
            type: shell
            in:
              - place: entrypoint
                pattern: _
            out:
              - place: entrypoint_
                pattern: ~(in.entrypoint)
              - place: /^steps\..+\.invocation-id$/
                pattern: ~(tr.stdout)
            command: plan --as-endpoint=$AS_ENDPOINT job.cwl ~(in.entrypoint) $REQUIREMENTS_FILE
            log:
              success: planSuccessLog ~(tr.stdout) ~(tag)
              failure: planFailureLog ~(tr.stdout) ~(tr.stderr) ~(tr.return) ~(tag) ~(interrupted)
  - target: tool
    precondition:
        - ./bin/needDockerRequirement ~(target)
        - which docker > /dev/null
    operations:
      - type: replace-env
        env:
          - name: EP3_LIBPATH
            value: $EP3_LIBPATH
          - name: PATH
            value: $EP3_EXT_PATH/dynreconf/bin:~(self)
          - name: AS_ENDPOINT
            value: $AS_ENDPOINT
      - type: add-in
        target: command-line-tool
        in:
          - place: invocation-id
            pattern: _
      - type: add-out
        target: prepare
        out:
          - place: Allocate
            pattern: not-started
      - type: add-transitions
        on:
          exit:
            - name: deallocate
              type: shell
              in:
                - place: resource
                  pattern: _
              command: deallocate --as-endpoint=$AS_ENDPOINT --nowait ~(in.resource)
              log:
                success: deallocateSuccessLog ~(tr.stdout) ~(tag)
                failure: deallocateFailureLog ~(tr.stdout) ~(tr.stderr) ~(tr.return) ~(tag)
        transitions:
          - name: allocate
            type: shell
            in:
              - place: Allocate
                pattern: not-started
              - place: input.json
                pattern: _
              - place: invocation-id
                pattern: _
            out:
              - place: Allocate
                pattern: success
              - place: input.json
                pattern: ~(in.input.json)
              - place: resource
                pattern: ~(tr.stdout)
            command: allocate --as-endpoint=$AS_ENDPOINT job.cwl ~(in.input.json) ~(in.invocation-id)
            log:
              success: allocateSuccessLog ~(tr.stdout) ~(tag)
              failure: allocateFailureLog ~(tr.stdout) ~(tr.stderr) ~(tr.return) ~(tag) ~(interrupted)
      - type: replace-transition
        target: execute
        transition:
          type: shell
          in:
            - place: Execution
              pattern: not-started
            - place: CommandGeneration
              pattern: success
            - place: CommandGeneration.command
              pattern: _
            - place: resource
              pattern: _
          out:
            - place: Execution.return
              pattern: ~(tr.return)
            - place: Execution.out
              pattern: ~(tr.stdout)
            - place: Execution.err
              pattern: ~(tr.stderr)
            - place: CommandGeneration.command
              pattern: ~(in.CommandGeneration.command)
            - place: resource
              pattern: ~(in.resource)
          command: |
            RESOURCE=$(jq '.result.endpoint' ~(in.resource))
            env DOCKER_HOST="$RESOURCE" executor ~(in.CommandGeneration.command)
          log:
            failure: commandFailureLog ~(in.CommandGeneration.command) ~(tr.stdout) ~(tr.stderr) ~(tr.return) ~(tag) ~(interrupted)
