#!/usr/bin/env ruby
# coding: utf-8
require 'optparse'
require 'json'
require 'net/http'
require_relative '../runtime/inspector'

def parse_option_file(file)
  if File.exist? file
    open(file) { |f|
      JSON.load(f)
    }
  else
    {}
  end
end

def get_request(endpoint)
  uri = URI.parse(endpoint)
  http = Net::HTTP.new(uri.host, uri.port)
  headers = { 'Content-Type' => 'application/json' }
  response = http.get(uri.path, headers)

  raise "Error in `#{endpoint}`: #{response.body}" if response.code != '201'

  JSON.load(response.body)
  # {
  #   delete_id: del-xxx,
  #   request_id: xxx,
  #   done: false
  # }
end

def poll(endpoint, timeout)
  uri = URI.parse(endpoint)
  http = Net::HTTP.new(uri.host, uri.port)
  headers = { 'Content-Type' => 'application/json' }
  start = Time.now
  json = nil
  (timeout/10.0).ceil.times{
    response = http.get(uri, headers)
    json = JSON.load(response.body)
    if response.code == '200'
      break if json['done']
    else
      warn "Warning: code: #{response.code}, body: #{JSON.dump(response.body)}"
    end

    break if Time.now-start > timeout
    sleep 10
  }
  json
end

if $0 == __FILE__
  options = {
    'ra' nil,
  }
  timeout = 10*60 # 10 min.
  nowait = false
  opt_file = '.reconf.json'
  opt = OptionParser.new
  opt.banner = "Usage: #{$0} [options] resource"
  # common options
  # res-id: A resource ID
  opt.on('--timeout=TO', "Timeout in seconds (default: #{timeout} sec.)") { |to|
    timeout = to.to_i
  }
  opt.on('--config=FILE',
         "A file name for configuration params such as ra and ms endpoints (default: #{opt_file})") { |f|
    unless File.exist? f
      warn "File not found: #{f}"
      exit 1
    end
    opt_file = f
  }

  # reconf deallocator specific options
  opt.on('--ra-endpoint=RA', 'An endpoint to an resource allocator') { |ra|
    options['ra'] = ra
  }
  opt.on('--nowait', 'Post parameters and immediately exit') {
    nowait = true
  }

  opt.parse!(ARGV)
  unless ARGV.length == 1
    puts opt.help
    exit
  end

  res = *ARGV
  raise "File not found: #{res}" unless File.exist? res

  options = parse_option_file(opt_file).merge(options)
  ra_server = options['ra']

  id = open(res) { |f|
    JSON.load(f)
  }['result']['resource_req_id']

  body = get_request("#{ra_server}/delete/#{id}")
  if nowait
    puts JSON.dump(body)
    exit
  end

  id = body['delete_id']
  deleted = poll("#{ra_server}/delete_status/#{id}", timeout)
  puts JSON.dump(deleted)
end
